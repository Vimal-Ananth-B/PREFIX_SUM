LEETCODE 724 : Find Pivot Index
Given an array of integers nums, calculate the pivot index of this array.
The pivot index is the index where the sum of all the numbers strictly to the left 
of the index is equal to the sum of all the numbers strictly to the index's right.
If the index is on the left edge of the array, then the left sum is 0 because there are 
no elements to the left. This also applies to the right edge of the array.
Return the leftmost pivot index. If no such index exists, return -1.

Example 1:
Input: nums = [1,7,3,6,5,6]
Output: 3
Explanation:
The pivot index is 3.
Left sum = nums[0] + nums[1] + nums[2] = 1 + 7 + 3 = 11
Right sum = nums[4] + nums[5] = 5 + 6 = 11

Example 2:
Input: nums = [1,2,3]
Output: -1
Explanation:
There is no index that satisfies the conditions in the problem statement.

Example 3:
Input: nums = [2,1,-1]
Output: 0
Explanation:
The pivot index is 0.
Left sum = 0 (no elements to the left of index 0)
Right sum = nums[1] + nums[2] = 1 + -1 = 0
----------------------------------------------------------------------------------------------------------------------------------------------------
ðŸ“Œ ALGORITHM (Prefix Sum Two-Array Method)

â€¢ Initialize two arrays leftSum[] and rightSum[] of size N.
â€¢ Initialize leftprefix = 0 and rightprefix = 0.

Step-1: Build Left Prefix Sum

â€¢ Traverse the array from left to right.
â€¢ Add current element to leftprefix.
â€¢ Store leftprefix in leftSum[i].

Step-2: Build Right Prefix Sum

â€¢ Traverse the array from right to left.
â€¢ Add current element to rightprefix.
â€¢ Store rightprefix in rightSum[i].

Step-3: Find Pivot Index

â€¢ Traverse from index 0 to N-1.
â€¢ If leftSum[i] == rightSum[i], return i as pivot index.
â€¢ If no such index is found, return -1.
-------------------------------------------------------------------------------------------------------------------------------------------------------
FIRST SOLUTION: TIME COMPLEXITY: O(N) || SPACE COMPLEXITY: O(N)
class Solution {
    public int pivotIndex(int[] nums) {
        int[] leftSum=new int[nums.length];
        int leftprefix=0,result=-1,rightprefix=0;
        int[] rightSum=new int[nums.length];
        for(int i=0;i<nums.length;i++)
        {
            leftprefix=leftprefix+nums[i];
            leftSum[i]=leftprefix;
        }
        for(int i=nums.length-1;i>=0;i--)
        {
            rightprefix=rightprefix+nums[i];
            rightSum[i]=rightprefix;
        }
        for(int i=0;i<nums.length;i++)
        {
            if(leftSum[i]==rightSum[i])
                {
                    result = i;
                    break;
                }
        }
        return result;
    }
}
-------------------------------------------------------------------------------------------------------------
SOLUTION: 2 (OPTIMAL VERSION) ---- ðŸ“Œ ALGORITHM (Bullet Documentation)
â€¢ Initialize totalSum to store sum of all elements.
â€¢ Traverse the array once and calculate totalSum.
â€¢ Initialize leftSum = 0.
â€¢ Traverse the array from index 0 to n-1:
 â€¢ totalSum= leftSum + Pivot + rightSum. here the pivot is what we need to find so we doing like this.
â€ƒâ€¢ Compute rightSum = totalSum - leftSum - nums[i].
â€ƒâ€¢ If leftSum == rightSum, return i as pivot index.
â€ƒâ€¢ Otherwise, add nums[i] to leftSum.
â€¢ If no pivot is found, return -1.
--------------------------------------------------------------------------------------------------------------
OPTIMAL SOLUTION : TIME COMPLEXITY:O(N) || SPACE COMPLEXITY:O(1)
class Solution {
    public int pivotIndex(int[] nums) {
        int leftSum=0,rightSum=0,totalSum=0,result=-1;
        for(int i=0;i<nums.length;i++)
        {
            totalSum=totalSum+nums[i];
        }
        for(int i=0;i<nums.length;i++)
        {
            rightSum=totalSum-leftSum-nums[i];
            if(rightSum==leftSum) 
            {
                result = i;
                break;
            }
            leftSum=leftSum+nums[i];
        }
        return result;
    }
}
